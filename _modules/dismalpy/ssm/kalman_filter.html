

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dismalpy.ssm.kalman_filter &mdash; DismalPy 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="../../../about.html"/>
    <link rel="top" title="DismalPy 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../contents.html" class="icon icon-home"> DismalPy
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">DismalPy User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user/ssm.html">State Space Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user/ssm.html#topics">Topics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/2-state_space_models.html">State space models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/3-python_representation.html">Representation in Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/4-maximum_likelihood_estimation.html">Maximum Likelihood Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/5-posterior_simulation.html">Posterior Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/6-out-of-the-box_models.html">Out-of-the-box models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/ssm/9-references.html">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/ssm.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/sarimax_internet.ipynb.html">Durbin and Koopman: Box-Jenkins Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/sarimax_stata.ipynb.html">SARIMAX: Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/local_linear_trend.ipynb.html">State space modeling: Local Linear Trends</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/structural_harvey_jaeger.ipynb.html">Detrending, Stylized Facts and the Business Cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/dfm_coincident.ipynb.html">Dynamic factors and coincident indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/_notebooks/varmax.ipynb.html">VARMAX models</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">DismalPy Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/ssm.html">State Space Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/ssm.html#built-in-models">Built-in models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/sarimax.html">SARIMAX</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/structural.html">Unobserved Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/varmax.html">VARMAX</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/dynamic_factor.html">Dynamic Factors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/ssm.html#extension-starting-point">Extension starting point</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/mlemodel.html">MLEModel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/ssm.html#base-classes">Base classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/representation.html">Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/kalman_filter.html">Kalman filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/kalman_smoother.html">Kalman smoother</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/simulation_smoother.html">Simulation Smoother</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/model.html">Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/ssm/tools.html">Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#dismalpy-0-2-0-release-notes">DismalPy 0.2.0 Release Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#highlights">Highlights</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../release.html#dismalpy-0-1-0-release-notes">DismalPy 0.1.0 Release Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#id1">Highlights</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#dropped-support">Dropped Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#future-changes">Future Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#compatibility-notes">Compatibility notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#new-features">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#improvements">Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#changes">Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../release.html#deprecations">Deprecations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">About DismalPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#about-this-documentation">About this documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../about.html#conventions">Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../bugs.html">Reporting bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">DismalPy License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../glossary.html#module-dismalpy.doc.jargon">Jargon</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../contents.html">DismalPy</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../contents.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>dismalpy.ssm.kalman_filter</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for dismalpy.ssm.kalman_filter</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Representation and Kalman Filter</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.representation</span> <span class="kn">import</span> <span class="n">OptionWrapper</span><span class="p">,</span> <span class="n">Representation</span><span class="p">,</span> <span class="n">FrozenRepresentation</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">prefix_kalman_filter_map</span><span class="p">,</span> <span class="n">validate_vector_shape</span><span class="p">,</span> <span class="n">validate_matrix_shape</span>
<span class="p">)</span>

<span class="c"># Define constants</span>
<span class="n">FILTER_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x01</span>     <span class="c"># Durbin and Koopman (2012), Chapter 4</span>
<span class="n">FILTER_EXACT_INITIAL</span> <span class="o">=</span> <span class="mh">0x02</span>    <span class="c"># ibid., Chapter 5.6</span>
<span class="n">FILTER_AUGMENTED</span> <span class="o">=</span> <span class="mh">0x04</span>        <span class="c"># ibid., Chapter 5.7</span>
<span class="n">FILTER_SQUARE_ROOT</span> <span class="o">=</span> <span class="mh">0x08</span>      <span class="c"># ibid., Chapter 6.3</span>
<span class="n">FILTER_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x10</span>       <span class="c"># ibid., Chapter 6.4</span>
<span class="n">FILTER_COLLAPSED</span> <span class="o">=</span> <span class="mh">0x20</span>        <span class="c"># ibid., Chapter 6.5</span>
<span class="n">FILTER_EXTENDED</span> <span class="o">=</span> <span class="mh">0x40</span>         <span class="c"># ibid., Chapter 10.2</span>
<span class="n">FILTER_UNSCENTED</span> <span class="o">=</span> <span class="mh">0x80</span>        <span class="c"># ibid., Chapter 10.3</span>

<span class="n">INVERT_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">SOLVE_LU</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">INVERT_LU</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">SOLVE_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">INVERT_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">INVERT_NUMPY</span> <span class="o">=</span> <span class="mh">0x20</span>

<span class="n">STABILITY_FORCE_SYMMETRY</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="n">MEMORY_STORE_ALL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">MEMORY_NO_FORECAST</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">MEMORY_NO_PREDICTED</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">MEMORY_NO_FILTERED</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">MEMORY_NO_GAIN</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">MEMORY_NO_SMOOTHING</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="n">MEMORY_CONSERVE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MEMORY_NO_FORECAST</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">|</span> <span class="n">MEMORY_NO_GAIN</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>
<span class="p">)</span>

<span class="n">TIMING_INIT_PREDICTED</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">TIMING_INIT_FILTERED</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="KalmanFilter"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter">[docs]</a><span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Representation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    State space representation of a time series process, with Kalman filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : array_like or integer</span>
<span class="sd">        The observed time-series process :math:`y` if array like or the</span>
<span class="sd">        number of variables in the process if an integer.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int, optional</span>
<span class="sd">        The dimension of a guaranteed positive definite covariance matrix</span>
<span class="sd">        describing the shocks in the measurement equation. Must be less than</span>
<span class="sd">        or equal to `k_states`. Default is `k_states`.</span>
<span class="sd">    loglikelihood_burn : int, optional</span>
<span class="sd">        The number of initial periods during which the loglikelihood is not</span>
<span class="sd">        recorded. Default is 0.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">        steady-state. Default is 1e-19.</span>
<span class="sd">    results_class : class, optional</span>
<span class="sd">        Default results class to use to save filtering output. Default is</span>
<span class="sd">        `FilterResults`. If specified, class must extend from `FilterResults`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide values for the filter,</span>
<span class="sd">        inversion, and stability methods. See `set_filter_method`,</span>
<span class="sd">        `set_inversion_method`, and `set_stability_method`.</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices. See `Representation` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several types of options available for controlling the Kalman</span>
<span class="sd">    filter operation. All options are internally held as bitmasks, but can be</span>
<span class="sd">    manipulated by setting class attributes, which act like boolean flags. For</span>
<span class="sd">    more information, see the `set_*` class method documentation. The options</span>
<span class="sd">    are:</span>

<span class="sd">    filter_method</span>
<span class="sd">        The filtering method controls aspects of which</span>
<span class="sd">        Kalman filtering approach will be used.</span>
<span class="sd">    inversion_method</span>
<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>
<span class="sd">    stability_method</span>
<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>
<span class="sd">    conserve_memory</span>
<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>
<span class="sd">    filter_timing</span>
<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">    The `filter_method` and `inversion_method` options intentionally allow</span>
<span class="sd">    the possibility that multiple methods will be indicated. In the case that</span>
<span class="sd">    multiple methods are selected, the underlying Kalman filter will attempt to</span>
<span class="sd">    select the optional method given the input data.</span>

<span class="sd">    For example, it may be that INVERT_UNIVARIATE and SOLVE_CHOLESKY are</span>
<span class="sd">    indicated (this is in fact the default case). In this case, if the</span>
<span class="sd">    endogenous vector is 1-dimensional (`k_endog` = 1), then INVERT_UNIVARIATE</span>
<span class="sd">    is used and inversion reduces to simple division, and if it has a larger</span>
<span class="sd">    dimension, the Cholesky decomposition along with linear solving (rather</span>
<span class="sd">    than explicit matrix inversion) is used. If only SOLVE_CHOLESKY had been</span>
<span class="sd">    set, then the Cholesky decomposition method would *always* be used, even in</span>
<span class="sd">    the case of 1-dimensional data.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FilterResults</span>
<span class="sd">    dismalpy.ssm.representation.Representation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;filter_conventional&#39;</span><span class="p">,</span> <span class="s">&#39;filter_exact_initial&#39;</span><span class="p">,</span> <span class="s">&#39;filter_augmented&#39;</span><span class="p">,</span>
        <span class="s">&#39;filter_square_root&#39;</span><span class="p">,</span> <span class="s">&#39;filter_univariate&#39;</span><span class="p">,</span> <span class="s">&#39;filter_collapsed&#39;</span><span class="p">,</span>
        <span class="s">&#39;filter_extended&#39;</span><span class="p">,</span> <span class="s">&#39;filter_unscented&#39;</span>
    <span class="p">]</span>

    <span class="n">filter_conventional</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CONVENTIONAL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for conventional Kalman filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_exact_initial</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXACT_INITIAL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for exact initial Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_augmented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_AUGMENTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for augmented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_square_root</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_SQUARE_ROOT</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for square-root Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate filtering of multivariate observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_collapsed</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_COLLAPSED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Kalman filtering with collapsed observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_extended</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXTENDED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for extended Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_unscented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNSCENTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for unscented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inversion_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;invert_univariate&#39;</span><span class="p">,</span> <span class="s">&#39;solve_lu&#39;</span><span class="p">,</span> <span class="s">&#39;invert_lu&#39;</span><span class="p">,</span> <span class="s">&#39;solve_cholesky&#39;</span><span class="p">,</span>
        <span class="s">&#39;invert_cholesky&#39;</span><span class="p">,</span> <span class="s">&#39;invert_numpy&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">invert_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU and linear solver inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky and linear solver inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_numpy</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_NUMPY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for inversion using numpy (not recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stability_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;stability_force_symmetry&#39;</span><span class="p">]</span>

    <span class="n">stability_force_symmetry</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;stability_method&#39;</span><span class="p">,</span> <span class="n">STABILITY_FORCE_SYMMETRY</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for enforcing covariance matrix symmetry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">memory_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;memory_store_all&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_forecast&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_predicted&#39;</span><span class="p">,</span>
        <span class="s">&#39;memory_no_filtered&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_likelihood&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_gain&#39;</span><span class="p">,</span>
        <span class="s">&#39;memory_no_smoothing&#39;</span><span class="p">,</span> <span class="s">&#39;memory_conserve&#39;</span>
    <span class="p">]</span>

    <span class="n">memory_store_all</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_STORE_ALL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for storing all intermediate results in memory (default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_forecast</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing forecasts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing predicted state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing filtered state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_likelihood</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_gain</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_GAIN</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing the Kalman gain matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_smoothing</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_SMOOTHING</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing temporary values used in smoothing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_conserve</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to conserve the maximum amount of memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timing_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;timing_init_predicted&#39;</span><span class="p">,</span> <span class="s">&#39;timing_init_filtered&#39;</span>
    <span class="p">]</span>
    <span class="n">timing_init_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="n">TIMING_INIT_PREDICTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the default timing convention (Durbin and Koopman, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timing_init_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="n">TIMING_INIT_FILTERED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the alternate timing convention (Kim and Nelson, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Default filter options</span>
    <span class="n">filter_method</span> <span class="o">=</span> <span class="n">FILTER_CONVENTIONAL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filtering method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_CHOLESKY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Inversion method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stability_method</span> <span class="o">=</span> <span class="n">STABILITY_FORCE_SYMMETRY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Stability method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">MEMORY_STORE_ALL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Memory conservation bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_timing</span> <span class="o">=</span> <span class="n">TIMING_INIT_PREDICTED</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filter timing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-19</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c"># Setup the underlying Kalman filter storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Filter options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">loglikelihood_burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">results_class</span> <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">FilterResults</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_timing</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_initialize_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filter_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inversion_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stability_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="k">if</span> <span class="n">filter_timing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filter_timing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c"># Make sure we have endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Must bind a dataset to the model before&#39;</span>
                               <span class="s">&#39; filtering or smoothing.&#39;</span><span class="p">)</span>

        <span class="c"># Initialize the representation matrices</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

        <span class="c"># Determine if we need to (re-)create the filter</span>
        <span class="c"># (definitely need to recreate if we recreated the _statespace object)</span>
        <span class="n">create_filter</span> <span class="o">=</span> <span class="n">create_statespace</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

            <span class="n">create_filter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">==</span> <span class="n">conserve_memory</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">==</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>

        <span class="c"># If the dtype-specific _kalman_filter does not exist (or if we need</span>
        <span class="c"># to re-create it), create it</span>
        <span class="k">if</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
                <span class="c"># Delete the old filter</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="c"># Setup the filter</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="n">prefix_kalman_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_statespaces</span><span class="p">[</span><span class="n">prefix</span><span class="p">],</span> <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="c"># Otherwise, update the filter parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">filter_timing</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
            <span class="c"># conserve_memory and loglikelihood_burn changes always lead to</span>
            <span class="c"># re-created filters</span>

        <span class="k">return</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span>

<div class="viewcode-block" id="KalmanFilter.set_filter_method"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : integer, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filtering method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        FILTER_CONVENTIONAL = 0x01</span>
<span class="sd">            Conventional Kalman filter.</span>
<span class="sd">        FILTER_UNIVARIATE = 0x10</span>
<span class="sd">            Univariate approach to Kalman filtering. Overrides conventional</span>
<span class="sd">            method if both are specified.</span>
<span class="sd">        FILTER_COLLAPSED = 0x20</span>
<span class="sd">            Collapsed approach to Kalman filtering. Will be used *in addition*</span>
<span class="sd">            to conventional or univariate filtering.</span>

<span class="sd">        If the bitmask is set directly via the `filter_method` argument, then</span>
<span class="sd">        the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the filter method may also be specified by directly modifying</span>
<span class="sd">        the class attributes which are defined similarly to the keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        The default filtering method is FILTER_CONVENTIONAL.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = dp.ssm.KalmanFilter(1,1)</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; mod.set_filter_method(filter_univariate=False,</span>
<span class="sd">                                  filter_collapsed=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        33</span>
<span class="sd">        &gt;&gt;&gt; mod.set_filter_method(filter_method=1)</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_univariate</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_collapsed</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">filter_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_inversion_method"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : integer, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The inversion method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        INVERT_UNIVARIATE = 0x01</span>
<span class="sd">            If the endogenous time series is univariate, then inversion can be</span>
<span class="sd">            performed by simple division. If this flag is set and the time</span>
<span class="sd">            series is univariate, then division will always be used even if</span>
<span class="sd">            other flags are also set.</span>
<span class="sd">        SOLVE_LU = 0x02</span>
<span class="sd">            Use an LU decomposition along with a linear solver (rather than</span>
<span class="sd">            ever actually inverting the matrix).</span>
<span class="sd">        INVERT_LU = 0x04</span>
<span class="sd">            Use an LU decomposition along with typical matrix inversion.</span>
<span class="sd">        SOLVE_CHOLESKY = 0x08</span>
<span class="sd">            Use a Cholesky decomposition along with a linear solver.</span>
<span class="sd">        INVERT_CHOLESKY = 0x10</span>
<span class="sd">            Use an Cholesky decomposition along with typical matrix inversion.</span>
<span class="sd">        INVERT_NUMPY = 0x20</span>
<span class="sd">            Use the numpy inversion function. This is not recommended except</span>
<span class="sd">            for testing as it will be substantially slower than the other</span>
<span class="sd">            methods.</span>

<span class="sd">        If the bitmask is set directly via the `inversion_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the inversion method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default inversion method is `INVERT_UNIVARIATE | SOLVE_CHOLESKY`</span>

<span class="sd">        Several things to keep in mind are:</span>

<span class="sd">        - If the filtering method is specified to be univariate, then simple</span>
<span class="sd">          division is always used regardless of the dimension of the endogenous</span>
<span class="sd">          time series.</span>
<span class="sd">        - Cholesky decomposition is about twice as fast as LU decomposition,</span>
<span class="sd">          but it requires that the matrix be positive definite. While this</span>
<span class="sd">          should generally be true, it may not be in every case.</span>
<span class="sd">        - Using a linear solver rather than true matrix inversion is generally</span>
<span class="sd">          faster and is numerically more stable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = dp.ssm.KalmanFilter(1,1)</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.solve_cholesky</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_univariate</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_lu</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_univariate = False</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; mod.set_inversion_method(solve_cholesky=False,</span>
<span class="sd">                                     invert_cholesky=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_stability_method"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : integer, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The stability method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        STABILITY_FORCE_SYMMETRY = 0x01</span>
<span class="sd">            If this flag is set, symmetry of the predicted state covariance</span>
<span class="sd">            matrix is enforced at each iteration of the filter, where each</span>
<span class="sd">            element is set to the average of the corresponding elements in the</span>
<span class="sd">            upper and lower triangle.</span>

<span class="sd">        If the bitmask is set directly via the `stability_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the stability method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default stability method is `STABILITY_FORCE_SYMMETRY`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = dp.ssm.KalmanFilter(1,1)</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_force_symmetry</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_force_symmetry = False</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_method</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_conserve_memory"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : integer, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The memory conservation method is defined by a collection of boolean</span>
<span class="sd">        flags, and is internally stored as a bitmask. The methods available</span>
<span class="sd">        are:</span>

<span class="sd">        MEMORY_STORE_ALL = 0</span>
<span class="sd">            Store all intermediate matrices. This is the default value.</span>
<span class="sd">        MEMORY_NO_FORECAST = 0x01</span>
<span class="sd">            Do not store the forecast, forecast error, or forecast error</span>
<span class="sd">            covariance matrices. If this option is used, the `predict` method</span>
<span class="sd">            from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_PREDICTED = 0x02</span>
<span class="sd">            Do not store the predicted state or predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED = 0x04</span>
<span class="sd">            Do not store the filtered state or filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_LIKELIHOOD = 0x08</span>
<span class="sd">            Do not store the vector of loglikelihood values for each</span>
<span class="sd">            observation. Only the sum of the loglikelihood values is stored.</span>
<span class="sd">        MEMORY_NO_GAIN = 0x10</span>
<span class="sd">            Do not store the Kalman gain matrices.</span>
<span class="sd">        MEMORY_NO_SMOOTHING = 0x20</span>
<span class="sd">            Do not store temporary variables related to Klaman smoothing. If</span>
<span class="sd">            this option is used, smoothing is unavailable.</span>
<span class="sd">        MEMORY_CONSERVE</span>
<span class="sd">            Do not store any intermediate matrices.</span>

<span class="sd">        If the bitmask is set directly via the `conserve_memory` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the memory conservation method may also be specified by</span>
<span class="sd">        directly modifying the class attributes which are defined similarly to</span>
<span class="sd">        the keyword arguments.</span>

<span class="sd">        The default memory conservation method is `MEMORY_STORE_ALL`, so that</span>
<span class="sd">        all intermediate matrices are stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = dp.ssm.KalmanFilter(1,1)</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; mod.memory_no_predicted</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.memory_no_predicted = True</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; mod.set_conserve_memory(memory_no_filtered=True,</span>
<span class="sd">                                    memory_no_forecast=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">conserve_memory</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_filter_timing"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.set_filter_timing">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate_timing</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the filter timing convention</span>

<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alternate_timing : integer, optional</span>
<span class="sd">            Whether or not to use the alternate timing convention. Default is</span>
<span class="sd">            unspecified.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alternate_timing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">alternate_timing</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;timing_init_predicted&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;timing_init_predicted&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s">&#39;timing_init_filtered&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;timing_init_filtered&#39;</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.filter"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Apply the Kalman filter to the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Determines which Kalman filter to use. Default is conventional.</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Determines which inversion technique to use. Default is by Cholesky</span>
<span class="sd">            decomposition.</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Determines which numerical stability techniques to use. Default is</span>
<span class="sd">            to enforce symmetry of the predicted state covariance matrix.</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Determines what output from the filter to store. Default is to</span>
<span class="sd">            store everything.</span>
<span class="sd">        filter_timing : int, optional</span>
<span class="sd">            Determines the timing convention of the filter. Default is that</span>
<span class="sd">            from Durbin and Koopman (2012), in which the filter is initialized</span>
<span class="sd">            with predicted values.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">            steady-state. Default is 1e-19.</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        results : class, object, or {&#39;loglikelihood&#39;}, optional</span>
<span class="sd">            If a class which is a subclass of FilterResults, then that class is</span>
<span class="sd">            instantiated and returned with the result of filtering. Classes</span>
<span class="sd">            must subclass FilterResults.</span>
<span class="sd">            If an object, then that object is updated with the new filtering</span>
<span class="sd">            results.</span>
<span class="sd">            If the string &#39;loglikelihood&#39;, then only the loglikelihood is</span>
<span class="sd">            returned as an ndarray.</span>
<span class="sd">            If None, then the default results object is updated with the</span>
<span class="sd">            result of filtering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Set the class to be the default results class, if None provided</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span>

        <span class="c"># Initialize the filter</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">(</span>
                <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span>
                <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

        <span class="c"># Instantiate a new results object, if required</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">FilterResults</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># Initialize the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>

        <span class="c"># Run the filter</span>
        <span class="n">kfilter</span><span class="p">()</span>

        <span class="c"># We may just want the loglikelihood</span>
        <span class="k">if</span> <span class="n">results</span> <span class="o">==</span> <span class="s">&#39;loglikelihood&#39;</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
            <span class="p">)</span>
        <span class="c"># Otherwise update the results object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Update the model features; unless we had to recreate the</span>
            <span class="c"># statespace, only update the filter options</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="ow">not</span> <span class="n">create_statespace</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</div>
<div class="viewcode-block" id="KalmanFilter.loglike"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood associated with the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The joint loglikelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;loglikelihood&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.loglikeobs"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood for each observation associated with the</span>
<span class="sd">        statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `loglikelihood_burn` is positive, then the entries in the returned</span>
<span class="sd">        loglikelihood vector are set to be zero for those initial time periods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array of float</span>
<span class="sd">            Array of loglikelihood values for each observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;loglikelihood&#39;</span>
        <span class="n">llf_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Set any burned observations to have zero likelihood</span>
        <span class="n">llf_obs</span><span class="p">[:</span><span class="n">loglikelihood_burn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">llf_obs</span>
</div>
<div class="viewcode-block" id="KalmanFilter.simulate"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        simulated_states : array</span>
<span class="sd">            An (nsimulations x k_states) array of simulated states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="c"># Check for valid number of simulations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span> <span class="ow">and</span> <span class="n">nsimulations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;In a time-varying model, cannot create more&#39;</span>
                             <span class="s">&#39; simulations than there are observations.&#39;</span><span class="p">)</span>

        <span class="c"># Check / generate measurement shocks</span>
        <span class="k">if</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">measurement_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid shape of provided measurement shocks.&#39;</span>
                                 <span class="s">&#39; Required (</span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">)&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s">&#39;obs_cov&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;obs_cov&#39;</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c"># Check / generate state shocks</span>
        <span class="k">if</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid shape of provided state shocks.&#39;</span>
                                 <span class="s">&#39; Required (</span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">).&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s">&#39;state_cov&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;state_cov&#39;</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c"># Get the initial states</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="ow">not</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid shape of provided initial state&#39;</span>
                                 <span class="s">&#39; vector. Required (</span><span class="si">%d</span><span class="s">, 1)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">==</span> <span class="s">&#39;known&#39;</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;approximate_diffuse&#39;</span><span class="p">,</span> <span class="s">&#39;stationary&#39;</span><span class="p">]:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                              <span class="n">initial_state</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                  <span class="n">initial_state</span><span class="p">):</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>

        <span class="c"># Holding variables for the simulations</span>
        <span class="n">simulated_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">simulated_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">simulated_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_state</span>

        <span class="c"># Perform iterations to create the new time series</span>
        <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_intercept_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">selection_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">):</span>
            <span class="c"># Get the current shocks (this accomodates time-varying matrices)</span>
            <span class="k">if</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">measurement_shock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">measurement_shock</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">state_shock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span>
                    <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;state_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state_shock</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

            <span class="c"># Get current-iteration matrices</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span><span class="p">:</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">state_intercept_t</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">selection_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

            <span class="n">obs_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
            <span class="n">design</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;design&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span>
            <span class="n">state_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="n">state_intercept_t</span><span class="p">]</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;transition&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">]</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;selection&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">selection_t</span><span class="p">]</span>

            <span class="c"># Iterate the measurement equation</span>
            <span class="n">simulated_obs</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">obs_intercept</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">measurement_shock</span><span class="p">)</span>

            <span class="c"># Iterate the state equation</span>
            <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">state_intercept</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">state_shock</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">simulated_obs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="KalmanFilter.impulse_responses"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.KalmanFilter.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Since the first step is the impulse itself, we actually want steps+1</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Check for what kind of impulse we want</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">impulse</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="ow">or</span> <span class="n">impulse</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid value for `impulse`. Must be the&#39;</span>
                                 <span class="s">&#39; of one of the state innovations.&#39;</span><span class="p">)</span>

            <span class="c"># Create the (non-orthogonalized) impulse vector</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>
            <span class="n">impulse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">impulse</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">impulse</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid impulse vector. Must be shaped&#39;</span>
                                 <span class="s">&#39; (</span><span class="si">%d</span><span class="s">,)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>

        <span class="c"># Orthogonalize the impulses, if requested, using Cholesky on the</span>
        <span class="c"># first state covariance matrix</span>
        <span class="k">if</span> <span class="n">orthogonalized</span><span class="p">:</span>
            <span class="n">state_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_chol</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>

        <span class="c"># If we have a time-invariant system, we can solve for the IRF directly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span><span class="p">:</span>
            <span class="c"># Get the state space matrices</span>
            <span class="n">design</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c"># Holding arrays</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c"># First iteration</span>
            <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>
            <span class="n">irf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c"># Iterations</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
                <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">irf</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

        <span class="c"># Otherwise, create a new model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Get the basic model components</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;obs&#39;</span><span class="p">,</span> <span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="s">&#39;state_intercept&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="c"># Allow additional specification</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Model has time-invariant </span><span class="si">%s</span><span class="s"> matrix, so the </span><span class="si">%s</span><span class="s">&#39;</span>
                       <span class="s">&#39; argument to `irf` has been ignored.&#39;</span><span class="p">)</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Impulse response functions for models with&#39;</span>
                         <span class="s">&#39; time-varying </span><span class="si">%s</span><span class="s"> matrix requires an updated&#39;</span>
                         <span class="s">&#39; time-varying matrix for any periods beyond those in&#39;</span>
                         <span class="s">&#39; the original model.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;obs&#39;</span><span class="p">,</span> <span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="s">&#39;state_intercept&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">warning</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>

            <span class="c"># Setup the new statespace representation</span>
            <span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;filter_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">,</span>
                <span class="s">&#39;inversion_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">,</span>
                <span class="s">&#39;stability_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">,</span>
                <span class="s">&#39;conserve_memory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">,</span>
                <span class="s">&#39;tolerance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="s">&#39;loglikelihood_burn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="p">}</span>
            <span class="n">model_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">()</span>

            <span class="c"># Get the impulse response function via simulation of the state</span>
            <span class="c"># space model, but with other shocks set to zero</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
            <span class="n">state_shocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">irf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="n">steps</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
                <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">)</span>

        <span class="c"># Get the cumulative response if requested</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">irf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">irf</span>

</div></div>
<div class="viewcode-block" id="FilterResults"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.FilterResults">[docs]</a><span class="k">class</span> <span class="nc">FilterResults</span><span class="p">(</span><span class="n">FrozenRepresentation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Kalman filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        The dimension of a guaranteed positive definite</span>
<span class="sd">        covariance matrix describing the shocks in the</span>
<span class="sd">        measurement equation.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Datatype of representation matrices</span>
<span class="sd">    prefix : str</span>
<span class="sd">        BLAS prefix of representation matrices</span>
<span class="sd">    shapes : dictionary of name,tuple</span>
<span class="sd">        A dictionary recording the shapes of each of the</span>
<span class="sd">        representation matrices as tuples.</span>
<span class="sd">    endog : array</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : array</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : array</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : array</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : array</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : array</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : array</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : array</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    missing : array of bool</span>
<span class="sd">        An array of the same size as `endog`, filled</span>
<span class="sd">        with boolean values that are True if the</span>
<span class="sd">        corresponding entry in `endog` is NaN and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    nmissing : array of int</span>
<span class="sd">        An array of size `nobs`, where the ith entry</span>
<span class="sd">        is the number (between 0 and `k_endog`) of NaNs in</span>
<span class="sd">        the ith row of the `endog` array.</span>
<span class="sd">    time_invariant : bool</span>
<span class="sd">        Whether or not the representation matrices are time-invariant</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Kalman filter initialization method.</span>
<span class="sd">    initial_state : array_like</span>
<span class="sd">        The state vector used to initialize the Kalamn filter.</span>
<span class="sd">    initial_state_cov : array_like</span>
<span class="sd">        The state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    filter_method : int</span>
<span class="sd">        Bitmask representing the Kalman filtering method</span>
<span class="sd">    inversion_method : int</span>
<span class="sd">        Bitmask representing the method used to</span>
<span class="sd">        invert the forecast error covariance matrix.</span>
<span class="sd">    stability_method : int</span>
<span class="sd">        Bitmask representing the methods used to promote</span>
<span class="sd">        numerical stability in the Kalman filter</span>
<span class="sd">        recursions.</span>
<span class="sd">    conserve_memory : int</span>
<span class="sd">        Bitmask representing the selected memory conservation method.</span>
<span class="sd">    filter_timing : int</span>
<span class="sd">        Whether or not to use the alternate timing convention.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance at which the Kalman filter</span>
<span class="sd">        determines convergence to steady-state.</span>
<span class="sd">    loglikelihood_burn : int</span>
<span class="sd">        The number of initial periods during which</span>
<span class="sd">        the loglikelihood is not recorded.</span>
<span class="sd">    converged : bool</span>
<span class="sd">        Whether or not the Kalman filter converged.</span>
<span class="sd">    period_converged : int</span>
<span class="sd">        The time period in which the Kalman filter converged.</span>
<span class="sd">    filtered_state : array</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : array</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : array</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : array</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    kalman_gain : array</span>
<span class="sd">        The Kalman gain at each time period.</span>
<span class="sd">    forecasts : array</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : array</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : array</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>
<span class="sd">    llf_obs : array</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    collapsed_forecasts : array</span>
<span class="sd">        If filtering using collapsed observations, stores the one-step-ahead</span>
<span class="sd">        forecasts of collapsed observations at each time period.</span>
<span class="sd">    collapsed_forecasts_error : array</span>
<span class="sd">        If filtering using collapsed observations, stores the one-step-ahead</span>
<span class="sd">        forecast errors of collapsed observations at each time period.</span>
<span class="sd">    collapsed_forecasts_error_cov : array</span>
<span class="sd">        If filtering using collapsed observations, stores the one-step-ahead</span>
<span class="sd">        forecast error covariance matrices of collapsed observations at each</span>
<span class="sd">        time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="s">&#39;stability_method&#39;</span><span class="p">,</span>
        <span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="s">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="s">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
        <span class="s">&#39;converged&#39;</span><span class="p">,</span> <span class="s">&#39;period_converged&#39;</span><span class="p">,</span> <span class="s">&#39;filtered_state&#39;</span><span class="p">,</span>
        <span class="s">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;kalman_gain&#39;</span><span class="p">,</span> <span class="s">&#39;tmp1&#39;</span><span class="p">,</span> <span class="s">&#39;tmp2&#39;</span><span class="p">,</span> <span class="s">&#39;tmp3&#39;</span><span class="p">,</span> <span class="s">&#39;tmp4&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts&#39;</span><span class="p">,</span>
        <span class="s">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s">&#39;llf_obs&#39;</span><span class="p">,</span>
        <span class="s">&#39;collapsed_forecasts&#39;</span><span class="p">,</span> <span class="s">&#39;collapsed_forecasts_error&#39;</span><span class="p">,</span>
        <span class="s">&#39;collapsed_forecasts_error_cov&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">_filter_options</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span> <span class="o">+</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
    <span class="p">)</span>

    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">FrozenRepresentation</span><span class="o">.</span><span class="n">_model_attributes</span> <span class="o">+</span> <span class="n">_filter_attributes</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c"># Setup caches for uninitialized objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="FilterResults.update_representation"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.FilterResults.update_representation">[docs]</a>    <span class="k">def</span> <span class="nf">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the results to match a given model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : Representation</span>
<span class="sd">            The model object from which to take the updated values.</span>
<span class="sd">        only_options : boolean, optional</span>
<span class="sd">            If set to true, only the filter options are updated, and the state</span>
<span class="sd">            space representation is not updated. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_options</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c"># Save the options as boolean variables</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_options</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FilterResults.update_filter"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.FilterResults.update_filter">[docs]</a>    <span class="k">def</span> <span class="nf">update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kalman_filter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the filter results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kalman_filter : KalmanFilter</span>
<span class="sd">            The model object from which to take the updated values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># State initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>

        <span class="c"># Save Kalman filter parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c"># Save Kalman filter output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_converged</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">period_converged</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Note: use forecasts rather than forecast, so as not to interfer</span>
        <span class="c"># with the `forecast` methods in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># If there was missing data, save the original values from the Kalman</span>
        <span class="c"># filter output, since below will set the values corresponding to</span>
        <span class="c"># the missing observations to nans.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Copy the provided arrays (which are as the Kalman filter dataset)</span>
            <span class="c"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c"># Save the collapsed values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
            <span class="c"># Copy the provided arrays (which are from the collapsed dataset)</span>
            <span class="c"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="c"># Recreate the original arrays (which should be from the original</span>
            <span class="c"># dataset) in the appropriate dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c"># Fill in missing values in the forecast, forecast error, and</span>
        <span class="c"># forecast error covariance matrix (this is required due to how the</span>
        <span class="c"># Kalman filter implements observations that are either partly or</span>
        <span class="c"># completely missing)</span>
        <span class="c"># Construct the predictions, forecasts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_cov_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c"># For completely missing observations, the Kalman filter will</span>
                <span class="c"># produce forecasts, but forecast errors and the forecast</span>
                <span class="c"># error covariance matrix will be zeros - make them nan to</span>
                <span class="c"># improve clarity of results.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                    <span class="c"># We can recover forecasts</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
                <span class="c"># For partially missing observations, the Kalman filter</span>
                <span class="c"># will produce all elements (forecasts, forecast errors,</span>
                <span class="c"># forecast error covariance matrices) as usual, but their</span>
                <span class="c"># dimension will only be equal to the number of non-missing</span>
                <span class="c"># elements, and their location in memory will be in the first</span>
                <span class="c"># blocks (e.g. for the forecasts_error, the first</span>
                <span class="c"># k_endog - nmissing[t] columns will be filled in), regardless</span>
                <span class="c"># of which endogenous variables they refer to (i.e. the non-</span>
                <span class="c"># missing endogenous variables for that observation).</span>
                <span class="c"># Furthermore, the forecast error covariance matrix is only</span>
                <span class="c"># valid for those elements. What is done is to set all elements</span>
                <span class="c"># to nan for these observations so that they are flagged as</span>
                <span class="c"># missing. The variables missing_forecasts, etc. then provide</span>
                <span class="c"># the forecasts, etc. provided by the Kalman filter, from which</span>
                <span class="c"># the data can be retrieved if desired.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="c"># In the collapsed case, everything just needs to be rebuilt</span>
                <span class="c"># for the original observed data, since the Kalman filter</span>
                <span class="c"># produced these values for the collapsed data.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standardized_forecasts_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardized forecast errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                            <span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span>

<div class="viewcode-block" id="FilterResults.predict"><a class="viewcode-back" href="../../../reference/ssm/kalman_filter.html#dismalpy.ssm.kalman_filter.FilterResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        In-sample and out-of-sample prediction for state space models generally</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast will be at start.</span>
<span class="sd">        end : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast will be at end.</span>
<span class="sd">        dynamic : int, optional</span>
<span class="sd">            Offset relative to `start` at which to begin dynamic prediction.</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the prediction range is outside of the sample range, any</span>
<span class="sd">            of the state space representation matrices that are time-varying</span>
<span class="sd">            must have updated values provided for the out-of-sample range.</span>
<span class="sd">            For example, of `obs_intercept` is a time-varying component and</span>
<span class="sd">            the prediction range extends 10 periods beyond the end of the</span>
<span class="sd">            sample, a (`k_endog` x 10) matrix must be provided with the new</span>
<span class="sd">            intercept values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : PredictionResults</span>
<span class="sd">            A PredictionResults object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All prediction is performed by applying the deterministic part of the</span>
<span class="sd">        measurement equation using the predicted state variables.</span>

<span class="sd">        Out-of-sample prediction first applies the Kalman filter to missing</span>
<span class="sd">        data for the number of periods desired to obtain the predicted states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Cannot predict if we do not have appropriate arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Predict is not possible if memory conservation&#39;</span>
                             <span class="s">&#39; has been used to avoid storing forecasts or&#39;</span>
                             <span class="s">&#39; predicted values.&#39;</span><span class="p">)</span>

        <span class="c"># Get the start and the end of the entire prediction range</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot predict values previous to the sample.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c"># Prediction and forecasting is performed by iterating the Kalman</span>
        <span class="c"># Kalman filter through the entire range [0, end]</span>
        <span class="c"># Then, unless `full_results=True`, forecasts are returned</span>
        <span class="c"># corresponding to the range [start, end].</span>
        <span class="c"># In order to perform the calculations, the range is separately split</span>
        <span class="c"># up into the following categories:</span>
        <span class="c"># - static:   (in-sample) the Kalman filter is run as usual</span>
        <span class="c"># - dynamic:  (in-sample) the Kalman filter is run, but on missing data</span>
        <span class="c"># - forecast: (out-of-sample) the Kalman filter is run, but on missing</span>
        <span class="c">#             data</span>

        <span class="c"># Short-circuit if end is before start</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;End of prediction must be after start.&#39;</span><span class="p">)</span>

        <span class="c"># Get the number of forecasts to make after the end of the sample</span>
        <span class="n">nforecast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c"># Get the number of dynamic prediction periods</span>

        <span class="c"># If `dynamic=True`, then assume that we want to begin dynamic</span>
        <span class="c"># prediction at the start of the sample prediction.</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># If `dynamic=False`, then assume we want no dynamic prediction</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">ndynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Replace the relative dynamic offset with an absolute offset</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dynamic</span>

            <span class="c"># Validate the `dynamic` parameter</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Dynamic prediction cannot begin prior to the&#39;</span>
                                 <span class="s">&#39; first observation in the sample.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s">&#39;Dynamic prediction specified to begin after the end of&#39;</span>
                     <span class="s">&#39; prediction, and so has no effect.&#39;</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s">&#39;Dynamic prediction specified to begin during&#39;</span>
                     <span class="s">&#39; out-of-sample forecasting period, and so has no&#39;</span>
                     <span class="s">&#39; effect.&#39;</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Get the total size of the desired dynamic forecasting component</span>
            <span class="c"># Note: the first `dynamic` periods of prediction are actually</span>
            <span class="c"># *not* dynamic, because dynamic prediction begins at observation</span>
            <span class="c"># `dynamic`.</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ndynamic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dynamic</span><span class="p">)</span>

        <span class="c"># Get the number of in-sample static predictions</span>
        <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">dynamic</span>

        <span class="c"># Construct the design and observation intercept and covariance</span>
        <span class="c"># matrices for start-npadded:end. If not time-varying in the original</span>
        <span class="c"># model, then they will be copied over if none are provided in</span>
        <span class="c"># `kwargs`. Otherwise additional matrices must be provided in `kwargs`.</span>
        <span class="n">representation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;obs&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c"># Update the matrices from kwargs for forecasts</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Model has time-invariant </span><span class="si">%s</span><span class="s"> matrix, so the </span><span class="si">%s</span><span class="s">&#39;</span>
                   <span class="s">&#39; argument to `predict` has been ignored.&#39;</span><span class="p">)</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Forecasting for models with time-varying </span><span class="si">%s</span><span class="s"> matrix&#39;</span>
                     <span class="s">&#39; requires an updated time-varying matrix for the&#39;</span>
                     <span class="s">&#39; period to be forecasted.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nforecast</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;obs&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">warning</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">validate_vector_shape</span><span class="p">(</span><span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>

        <span class="c"># Update the matrices from kwargs for dynamic prediction in the case</span>
        <span class="c"># that `end` is less than `nobs` and `dynamic` is less than `end`. In</span>
        <span class="c"># this case, any time-varying matrices in the default `representation`</span>
        <span class="c"># will be too long, causing an error to be thrown below in the</span>
        <span class="c"># KalmanFilter(...) construction call, because the endog has length</span>
        <span class="c"># nstatic + ndynamic + nforecast, whereas the time-varying matrices</span>
        <span class="c"># from `representation` have length nobs.</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;obs&#39;</span> <span class="ow">and</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="c"># Construct the predicted state and covariance matrix for each time</span>
        <span class="c"># period depending on whether that time period corresponds to</span>
        <span class="c"># one-step-ahead prediction, dynamic prediction, or out-of-sample</span>
        <span class="c"># forecasting.</span>

        <span class="c"># If we only have simple prediction, then we can use the already saved</span>
        <span class="c"># Kalman filter output</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nforecast</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Construct the new endogenous array.</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">ndynamic</span> <span class="o">+</span> <span class="n">nforecast</span><span class="p">))</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nstatic</span><span class="p">],</span> <span class="n">endog</span><span class="p">])</span>

            <span class="c"># Setup the new statespace representation</span>
            <span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;filter_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">,</span>
                <span class="s">&#39;inversion_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">,</span>
                <span class="s">&#39;stability_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">,</span>
                <span class="s">&#39;conserve_memory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">,</span>
                <span class="s">&#39;tolerance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="s">&#39;loglikelihood_burn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="p">}</span>
            <span class="n">model_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">()</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">(</span><span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PredictionResults</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span>
                                 <span class="n">nforecast</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="c"># TODO: this doesn&#39;t use self, and can either be a static method or</span>
        <span class="c">#       moved outside the class altogether.</span>

        <span class="c"># Get the underlying filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_kalman_filter</span>

        <span class="c"># Save this (which shares memory with the memoryview on which the</span>
        <span class="c"># Kalman filter will be operating) so that we can replace actual data</span>
        <span class="c"># with predicted data during dynamic forecasting</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_representations</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">prefix</span><span class="p">][</span><span class="s">&#39;obs&#39;</span><span class="p">]</span>

        <span class="c"># print(nstatic, ndynamic, nforecast, model.nobs)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="c"># Run the Kalman filter for the first `nstatic` periods (for</span>
            <span class="c"># which dynamic computation will not be performed)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c"># Perform dynamic prediction</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span> <span class="o">+</span> <span class="n">ndynamic</span><span class="p">:</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c"># Unconditional value is the intercept (often zeros)</span>
                <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                <span class="c"># If t &gt; 0, then we can condition the forecast on the state</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Predict endog[:, t] given `predicted_state` calculated in</span>
                    <span class="c"># previous iteration (i.e. t-1)</span>
                    <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                        <span class="n">kfilter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="c"># Advance Kalman filter</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c"># Perform any (one-step-ahead) forecasting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="c"># Return the predicted state and predicted state covariance matrices</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">FilterResults</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

</div>
<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Results of in-sample and out-of-sample prediction for state space models</span>
<span class="sd">    generally</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : FilterResults</span>
<span class="sd">        Output from filtering, corresponding to the prediction desired</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">        i.e., the first forecast will be at start.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">        the last forecast will be at end.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions (these are always the first</span>
<span class="sd">        elements of the prediction output).</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions (these always follow the static</span>
<span class="sd">        predictions directly, and are directly followed by the forecasts).</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts (these always follow the dynamic</span>
<span class="sd">        predictions directly).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    npredictions : int</span>
<span class="sd">        Number of observations in the predicted series; this is not necessarily</span>
<span class="sd">        the same as the number of observations in the original model from which</span>
<span class="sd">        prediction was performed.</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start prediction,</span>
<span class="sd">        i.e., the first predict will be at `start`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end prediction,</span>
<span class="sd">        i.e., the last predict will be at `end`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions.</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts.</span>
<span class="sd">    endog : array</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : array</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : array</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : array</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : array</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : array</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : array</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : array</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    filtered_state : array</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : array</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : array</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : array</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecasts : array</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : array</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : array</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The provided ranges must be conformable, meaning that it must be that</span>
<span class="sd">    `end - start == nstatic + ndynamic + nforecast`.</span>

<span class="sd">    This class is essentially a view to the FilterResults object, but</span>
<span class="sd">    returning the appropriate ranges for everything.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">representation_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;endog&#39;</span><span class="p">,</span> <span class="s">&#39;design&#39;</span><span class="p">,</span> <span class="s">&#39;design&#39;</span><span class="p">,</span> <span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span>
        <span class="s">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="s">&#39;transition&#39;</span><span class="p">,</span> <span class="s">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="s">&#39;selection&#39;</span><span class="p">,</span>
        <span class="s">&#39;state_cov&#39;</span>
    <span class="p">]</span>
    <span class="n">filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s">&#39;filtered_state_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error_cov&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

        <span class="c"># Save the filter results object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>

        <span class="c"># Save prediction ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npredictions</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstatic</span> <span class="o">=</span> <span class="n">nstatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">=</span> <span class="n">ndynamic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span> <span class="o">=</span> <span class="n">nforecast</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide access to the representation and filtered output in the</span>
<span class="sd">        appropriate range (`start` - `end`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Prevent infinite recursive lookups</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">_attr</span> <span class="o">=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr</span>

        <span class="c"># Cache the attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s">&#39;endog&#39;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">:</span>
                <span class="c"># Get a copy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c"># Subset to the correct time frame</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c"># If a time-invariant matrix, return it. Otherwise, subset to</span>
                <span class="c"># the correct period.</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Chad Fulton.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>