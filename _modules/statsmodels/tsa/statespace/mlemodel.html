

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>statsmodels.tsa.statespace.mlemodel &mdash; DismalPy 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="../../../../about.html"/>
    <link rel="top" title="DismalPy 0.1.0 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../../contents.html" class="icon icon-home"> DismalPy
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">DismalPy User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../user/ssm.html">State Space Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../user/ssm.html#topics">Topics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/2-state_space_models.html">State space models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/3-python_representation.html">Representation in Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/4-maximum_likelihood_estimation.html">Maximum Likelihood Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/5-posterior_simulation.html">Posterior Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/6-out-of-the-box_models.html">Out-of-the-box models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/ssm/9-references.html">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../user/ssm.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/sarimax_internet.ipynb.html">Durbin and Koopman: Box-Jenkins Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/sarimax_stata.ipynb.html">SARIMAX: Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/local_linear_trend.ipynb.html">State space modeling: Local Linear Trends</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/structural_harvey_jaeger.ipynb.html">Detrending, Stylized Facts and the Business Cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/dfm_coincident.ipynb.html">Dynamic factors and coincident indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../user/_notebooks/varmax.ipynb.html">VARMAX models</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/index.html">DismalPy Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/ssm.html">State Space Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../reference/ssm.html#built-in-models">Built-in models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/sarimax.html">SARIMAX</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/structural.html">Unobserved Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/varmax.html">VARMAX</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/dynamic_factor.html">Dynamic Factors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../reference/ssm.html#extension-starting-point">Extension starting point</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/mlemodel.html">MLEModel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../reference/ssm.html#base-classes">Base classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/representation.html">Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/kalman_filter.html">Kalman filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/kalman_smoother.html">Kalman smoother</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/simulation_smoother.html">Simulation Smoother</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/model.html">Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../reference/ssm/tools.html">Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../release.html#dismalpy-0-2-0-release-notes">DismalPy 0.2.0 Release Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#highlights">Highlights</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../release.html#dismalpy-0-1-0-release-notes">DismalPy 0.1.0 Release Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#id1">Highlights</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#dropped-support">Dropped Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#future-changes">Future Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#compatibility-notes">Compatibility notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#new-features">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#improvements">Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#changes">Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../release.html#deprecations">Deprecations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../about.html">About DismalPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../about.html#about-this-documentation">About this documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../about.html#conventions">Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bugs.html">Reporting bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">DismalPy License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../glossary.html#module-dismalpy.doc.jargon">Jargon</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../contents.html">DismalPy</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../contents.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
    <li>statsmodels.tsa.statespace.mlemodel</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for statsmodels.tsa.statespace.mlemodel</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Model</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">.kalman_smoother</span> <span class="kn">import</span> <span class="n">KalmanSmoother</span><span class="p">,</span> <span class="n">SmootherResults</span>
<span class="kn">from</span> <span class="nn">.kalman_filter</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">KalmanFilter</span><span class="p">,</span> <span class="n">FilterResults</span><span class="p">,</span> <span class="n">PredictionResults</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">,</span> <span class="n">SOLVE_LU</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="kn">as</span> <span class="nn">tsbase</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="kn">as</span> <span class="nn">wrap</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_get_epsilon</span><span class="p">,</span> <span class="n">approx_hess_cs</span><span class="p">,</span> <span class="n">approx_fprime_cs</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span><span class="p">,</span> <span class="n">resettable_cache</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="kn">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">pinv_extended</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">import</span> <span class="nn">statsmodels.genmod._prediction</span> <span class="kn">as</span> <span class="nn">pred</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.families.links</span> <span class="kn">import</span> <span class="n">identity</span>


<span class="k">class</span> <span class="nc">MLEModel</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    State space model for maximum likelihood estimation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The observed time-series process :math:`y`</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    exog : array_like, optional</span>
<span class="sd">        Array of exogenous regressors, shaped nobs x k. Default is no</span>
<span class="sd">        exogenous regressors.</span>
<span class="sd">    dates : array-like of datetime, optional</span>
<span class="sd">        An array-like object of datetime objects. If a Pandas object is given</span>
<span class="sd">        for endog, it is assumed to have a DateIndex.</span>
<span class="sd">    freq : str, optional</span>
<span class="sd">        The frequency of the time-series. A Pandas offset or &#39;B&#39;, &#39;D&#39;, &#39;W&#39;,</span>
<span class="sd">        &#39;M&#39;, &#39;A&#39;, or &#39;Q&#39;. This is optional if dates are given.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices or for Kalman filtering options. See `Representation`, and</span>
<span class="sd">        `KalmanFilter` for more details.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ssm : KalmanFilter</span>
<span class="sd">        Underlying state space representation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class wraps the state space model with Kalman filtering to add in</span>
<span class="sd">    functionality for maximum likelihood estimation. In particular, it adds</span>
<span class="sd">    the concept of updating the state space representation based on a defined</span>
<span class="sd">    set of parameters, through the `update` method or `updater` attribute (see</span>
<span class="sd">    below for more details on which to use when), and it adds a `fit` method</span>
<span class="sd">    which uses a numerical optimizer to select the parameters that maximize</span>
<span class="sd">    the likelihood of the model.</span>

<span class="sd">    The `start_params` `update` method must be overridden in the</span>
<span class="sd">    child class (and the `transform` and `untransform` methods, if needed).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEResults</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">optim_hessian</span> <span class="o">=</span> <span class="s">&#39;cs&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Initialize the model base</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                              <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                              <span class="n">missing</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>

        <span class="c"># Store kwargs to recreate model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c"># Prepared the endog array: C-ordered, shape=(nobs x k_endog)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">()</span>

        <span class="c"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="n">k_states</span>

        <span class="c"># Initialize the state-space representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_statespace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.prepare_data"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.prepare_data">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare data for use in the state space representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">)</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c"># Base class may allow 1-dim data, whereas we need 2-dim</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># this will be C-contiguous</span>

        <span class="c"># Base classes data may be either C-ordered or F-ordered - we want it</span>
        <span class="c"># to be C-ordered since it will also be in shape (nobs, k_endog), and</span>
        <span class="c"># then we can just transpose it.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">endog</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
            <span class="c"># TODO this breaks the reference link between the model endog</span>
            <span class="c"># variable and the original object - do we need a warn(&#39;&#39;)?</span>
            <span class="c"># This will happen often with Pandas DataFrames, which are often</span>
            <span class="c"># Fortran-ordered and in the long format</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span>
</div>
    <span class="k">def</span> <span class="nf">initialize_statespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the state space representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the state space class</span>
<span class="sd">            constructor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># (Now self.endog is C-ordered and in long format (nobs x k_endog). To</span>
        <span class="c"># get F-ordered and in wide format just need to transpose)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span>

        <span class="c"># Instantiate the state space object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span> <span class="o">=</span> <span class="n">KalmanSmoother</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># Bind the data to the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>

        <span class="c"># Other dimensions, now that `ssm` is available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_endog</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.set_filter_method"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : integer, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.set_inversion_method"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : integer, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="n">inversion_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.set_stability_method"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : integer, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="n">stability_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.set_conserve_memory"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : integer, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.set_smoother_output"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.set_smoother_output">[docs]</a>    <span class="k">def</span> <span class="nf">set_smoother_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoother_output</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the smoother output</span>

<span class="sd">        The smoother can produce several types of results. The smoother output</span>
<span class="sd">        variable controls which are calculated and returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smoother_output : integer, optional</span>
<span class="sd">            Bitmask value to set the smoother output to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the smoother output by</span>
<span class="sd">            setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanSmoother` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_smoother_output</span><span class="p">(</span><span class="n">smoother_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initialize_approximate_diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_approximate_diffuse</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initialize_stationary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_stationary</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span>
    <span class="nd">@initial_variance.setter</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
    <span class="nd">@loglikelihood_burn.setter</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span>
    <span class="nd">@tolerance.setter</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;opg&#39;</span><span class="p">,</span>
            <span class="n">cov_kwds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">optim_hessian</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - &#39;newton&#39; for Newton-Raphson, &#39;nm&#39; for Nelder-Mead</span>
<span class="sd">            - &#39;bfgs&#39; for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - &#39;lbfgs&#39; for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - &#39;powell&#39; for modified Powell&#39;s method</span>
<span class="sd">            - &#39;cg&#39; for conjugate gradient</span>
<span class="sd">            - &#39;ncg&#39; for Newton-conjugate gradient</span>
<span class="sd">            - &#39;basinhopping&#39; for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">            - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - &#39;cs&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using a numerical (complex step) approximation of the Hessian</span>
<span class="sd">              matrix.</span>
<span class="sd">            - &#39;delta&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using a numerical (complex step) approximation of the Hessian</span>
<span class="sd">              along with the delta method (method of propagation of errors)</span>
<span class="sd">              applied to the parameter transformation function</span>
<span class="sd">              `transform_params`.</span>
<span class="sd">            - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presense of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">              method.</span>
<span class="sd">            - &#39;robust_cs&#39; is the same as &#39;robust&#39; except that the intermediate</span>
<span class="sd">              calculations use the &#39;cs&#39; method.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : boolean, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : boolean, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : boolean, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_hessian : {&#39;opg&#39;,&#39;oim&#39;,&#39;cs&#39;}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. &#39;opg&#39;</span>
<span class="sd">            uses outer product of gradients, &#39;oim&#39; uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and &#39;cs&#39; uses second-order</span>
<span class="sd">            complex step differentiation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MLEResults</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        MLEResults</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Update the hessian method</span>
        <span class="k">if</span> <span class="n">optim_hessian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optim_hessian</span> <span class="o">=</span> <span class="n">optim_hessian</span>

        <span class="c"># Unconstrain the starting parameters</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;lbfgs&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;bfgs&#39;</span><span class="p">:</span>
            <span class="c"># kwargs.setdefault(&#39;pgtol&#39;, 1e-8)</span>
            <span class="c"># kwargs.setdefault(&#39;factr&#39;, 1e2)</span>
            <span class="c"># kwargs.setdefault(&#39;m&#39;, 12)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;approx_grad&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;epsilon&#39;</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>

        <span class="c"># Maximum likelihood estimation</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">False</span><span class="p">,)</span>  <span class="c"># (sets transformed=False)</span>
        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                  <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                                  <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                                  <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                                  <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                                  <span class="n">skip_hessian</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                              <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

            <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman filtering</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : boolean,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Wrap in a results object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ssm</span><span class="p">:</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">MLEResultsWrapper</span><span class="p">(</span>
                <span class="n">MLEResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman smoothing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : boolean,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Wrap in a results object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ssm</span><span class="p">:</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">MLEResultsWrapper</span><span class="p">(</span>
                <span class="n">MLEResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MLEModel.loglike"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        \*\*kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the model to reflect new params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">loglike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Koopman, Shephard, and Doornik recommend maximizing the average</span>
        <span class="c"># likelihood to avoid scale issues, but the averaging is done</span>
        <span class="c"># automatically in the base model `fit` method</span>
        <span class="k">return</span> <span class="n">loglike</span>
</div>
<div class="viewcode-block" id="MLEModel.loglikeobs"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the Model to reflect new params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.observed_information_matrix"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.observed_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Observed information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), which shows that the information</span>
<span class="sd">        matrix only depends on terms from the gradient. This implementation is</span>
<span class="sd">        partially analytic and partially numeric approximation, therefore,</span>
<span class="sd">        because it uses the analytic formula for the information matrix, with</span>
<span class="sd">        numerically computed elements of the gradient.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">epsilon</span>

        <span class="c"># Get values at the params themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c"># Save this for inversion later</span>
        <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Compute partial derivatives</span>
        <span class="n">partials_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ih</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">increments</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ih</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c"># Compute the information matrix</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                    <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                              <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span>
                        <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">[:,:,</span><span class="n">t</span><span class="p">],</span>
                               <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">information_matrix</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.opg_information_matrix"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.opg_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">opg_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Outer product of gradients information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglikeobs` method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Berndt, Ernst R., Bronwyn Hall, Robert Hall, and Jerry Hausman. 1974.</span>
<span class="sd">        Estimation and Inference in Nonlinear Structural Models.</span>
<span class="sd">        NBER Chapters. National Bureau of Economic Research, Inc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.score"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        score : array</span>
<span class="sd">            Score, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglike` method.</span>

<span class="sd">        Both \*args and \*\*kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        \*args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">transformed</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;transformed&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s">&#39;transformed&#39;</span><span class="p">:</span> <span class="n">transformed</span>
        <span class="p">})</span>

        <span class="k">return</span> <span class="n">score</span>
</div>
<div class="viewcode-block" id="MLEModel.score_obs"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>
<span class="sd"> </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        score : array (nobs, k_vars)</span>
<span class="sd">            Score per observation, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglikeobs` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.hessian"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the hessian.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hessian : array</span>
<span class="sd">            Hessian matrix evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation.</span>

<span class="sd">        Both \*args and \*\*kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        \*args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_hessian</span> <span class="o">==</span> <span class="s">&#39;cs&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_hessian</span> <span class="o">==</span> <span class="s">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_oim</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">optim_hessian</span> <span class="o">==</span> <span class="s">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Invalid Hessian calculation method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hessian</span>
</div>
    <span class="k">def</span> <span class="nf">_hessian_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the Harvey (1989) information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the outer product of gradients</span>
<span class="sd">        information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">opg_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed by second-order complex-step differentiation</span>
<span class="sd">        on the `loglike` function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transformed</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;transformed&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_hess_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s">&#39;transformed&#39;</span><span class="p">:</span> <span class="n">transformed</span>
        <span class="p">})</span>

        <span class="k">return</span> <span class="n">hessian</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_start_params&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_param_names&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;param.</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_params</span><span class="p">))]</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">names</span>

<div class="viewcode-block" id="MLEModel.transform_jacobian"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.transform_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">transform_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian matrix for the parameter transformation function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian : array</span>
<span class="sd">            Jacobian matrix of the transformation, evaluated at `unconstrained`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transform_params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.transform_params"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.transform_params">[docs]</a>    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evalation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.untransform_params"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.untransform_params">[docs]</a>    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evalution, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEModel.update"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of the model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since Model is a base class, this method should be overridden by</span>
<span class="sd">        subclasses to perform actual updating steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">params</span>
</div>
<div class="viewcode-block" id="MLEModel.simulate"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">simulated_obs</span><span class="p">,</span> <span class="n">simulated_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>

        <span class="c"># Simulated obs is (k_endog x nobs); don&#39;t want to squeeze in</span>
        <span class="c"># case of npredictions = 1</span>
        <span class="k">if</span> <span class="n">simulated_obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">simulated_obs</span> <span class="o">=</span> <span class="n">simulated_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">simulated_obs</span> <span class="o">=</span> <span class="n">simulated_obs</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">simulated_obs</span>
</div>
<div class="viewcode-block" id="MLEModel.impulse_responses"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="MLEModel.from_formula"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEModel.from_formula">[docs]</a>    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not implemented for state space models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<span class="k">class</span> <span class="nc">MLEResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Class to hold results from fitting a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : array</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : array</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 and not used by the model or its results.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEModel</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.FrozenRepresentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;opg&#39;</span><span class="p">,</span>
                 <span class="n">cov_kwds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c"># Save the state space representation output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">SmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;cov_kwds&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>

        <span class="c"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Covariance matrix could not be calculated: singular.&#39;</span>
                <span class="s">&#39; information matrix.&#39;</span><span class="p">)</span>

        <span class="c"># References of filter and smoother output</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s">&#39;predicted_state&#39;</span><span class="p">,</span>
                     <span class="s">&#39;predicted_state_cov&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error&#39;</span><span class="p">,</span>
                     <span class="s">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s">&#39;smoothed_state&#39;</span><span class="p">,</span>
                     <span class="s">&#39;smoothed_state_cov&#39;</span><span class="p">,</span> <span class="s">&#39;smoothed_measurement_disturbance&#39;</span><span class="p">,</span>
                     <span class="s">&#39;smoothed_state_disturbance&#39;</span><span class="p">,</span>
                     <span class="s">&#39;smoothed_measurement_disturbance_cov&#39;</span><span class="p">,</span>
                     <span class="s">&#39;smoothed_state_disturbance_cov&#39;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;opg&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create new results instance with specified covariance estimator as</span>
<span class="sd">        default</span>

<span class="sd">        Note: creating new results instance currently not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov_type : string</span>
<span class="sd">            the type of covariance matrix estimator to use. See Notes below</span>
<span class="sd">        kwargs : depends on cov_type</span>
<span class="sd">            Required or optional arguments for covariance calculation.</span>
<span class="sd">            See Notes below.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : results instance</span>
<span class="sd">            This method creates a new results instance with the requested</span>
<span class="sd">            covariance as the default covariance of the parameters.</span>
<span class="sd">            Inferential statistics like p-values and hypothesis tests will be</span>
<span class="sd">            based on this covariance matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The following covariance types and required or optional arguments are</span>
<span class="sd">        currently available:</span>

<span class="sd">        - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">        - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">          using the method of Harvey (1989)</span>
<span class="sd">        - &#39;cs&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">          using a numerical (complex step) approximation of the Hessian</span>
<span class="sd">          matrix.</span>
<span class="sd">        - &#39;delta&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">          using a numerical (complex step) approximation of the Hessian along</span>
<span class="sd">          with the delta method (method of propagation of errors)</span>
<span class="sd">          applied to the parameter transformation function `transform_params`.</span>
<span class="sd">        - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">          matrix that may be valid even in the presense of some</span>
<span class="sd">          misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">          method.</span>
<span class="sd">        - &#39;robust_cs&#39; is the same as &#39;robust&#39; except that the intermediate</span>
<span class="sd">          calculations use the &#39;cs&#39; method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">statsmodels.stats.sandwich_covariance</span> <span class="kn">as</span> <span class="nn">sw</span>

        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;use_self&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Calculate the new covariance matrix</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;No parameters estimated.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;cs&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_cs</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Covariance matrix calculated using numerical (complex-step)&#39;</span>
                <span class="s">&#39; differentiation.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;delta&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_delta</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Covariance matrix calculated using numerical differentiation&#39;</span>
                <span class="s">&#39; and the delta method (method of propagation of errors)&#39;</span>
                <span class="s">&#39; applied to the parameter transformation function.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Covariance matrix calculated using the observed information&#39;</span>
                <span class="s">&#39; matrix described in Harvey (1989).&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Covariance matrix calculated using the outer product of&#39;</span>
                <span class="s">&#39; gradients.&#39;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;robust&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;robust_oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Quasi-maximum likelihood covariance matrix used for&#39;</span>
                <span class="s">&#39; robustness to some misspecifications; calculated using the&#39;</span>
                <span class="s">&#39; observed information matrix described in Harvey (1989).&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s">&#39;robust_cs&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_cs</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;Quasi-maximum likelihood covariance matrix used for&#39;</span>
                <span class="s">&#39; robustness to some misspecifications; calculated using&#39;</span>
                <span class="s">&#39; numerical (complex-step) differentiation.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Invalid covariance matrix type.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.aic"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.aic">[docs]</a>    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># return -2*self.llf + 2*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.bic"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.bic">[docs]</a>    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># return -2*self.llf + self.params.shape[0]*np.log(self.nobs)</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_cs"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_cs">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian computed without using parameter transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="c"># When using complex-step methods, cannot rely on Cholesky inversion</span>
        <span class="c"># because variance parameters will then have a complex component which</span>
        <span class="c"># which implies non-positive-definiteness.</span>
        <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_cs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="n">inversion_method</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">nobs</span> <span class="o">*</span> <span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_delta"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_delta">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian computed using parameter transformations and the Delta method</span>
<span class="sd">        (method of propagation of errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="n">unconstrained</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">transform_jacobian</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
        <span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_cs</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="o">-</span><span class="n">neg_cov</span><span class="p">),</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_oim"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_oim">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the method</span>
<span class="sd">        from Harvey (1989).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_opg"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_opg">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="c"># When using complex-step methods, cannot rely on Cholesky inversion</span>
        <span class="c"># because variance parameters will then have a complex component which</span>
        <span class="c"># which implies non-positive-definiteness.</span>
        <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">nobs</span> <span class="o">*</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">opg_information_matrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="n">inversion_method</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_robust"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_robust">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Alias for</span>
<span class="sd">        `cov_params_robust_oim`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_robust_oim"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_robust_oim">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        method from Harvey (1989) as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_opg</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.cov_params_robust_cs"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.cov_params_robust_cs">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_robust_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian computed without using parameter transformations as</span>
<span class="sd">        the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_opg</span>
        <span class="c"># When using complex-step methods, cannot rely on Cholesky inversion</span>
        <span class="c"># because variance parameters will then have a complex component which</span>
        <span class="c"># which implies non-positive-definiteness.</span>
        <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nobs</span> <span class="o">*</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_cs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">inversion_method</span><span class="o">=</span><span class="n">inversion_method</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.fittedvalues"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.fittedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This is a (k_endog x nobs array; don&#39;t want to squeeze in case of</span>
        <span class="c"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">fittedvalues</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.hqic"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.hqic">[docs]</a>    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># return -2*self.llf + 2*np.log(np.log(self.nobs))*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.llf_obs"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.llf_obs">[docs]</a>    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.llf"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.llf">[docs]</a>    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.loglikelihood_burn"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.loglikelihood_burn">[docs]</a>    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The number of observations during which the likelihood is not</span>
<span class="sd">        evaluated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.pvalues"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.pvalues">[docs]</a>    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The p-values associated with the z-statistics of the</span>
<span class="sd">        coefficients. Note that the coefficients are assumed to have a Normal</span>
<span class="sd">        distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.resid"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.resid">[docs]</a>    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This is a (k_endog x nobs array; don&#39;t want to squeeze in case of</span>
        <span class="c"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">forecasts_error</span>
        <span class="k">if</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">resid</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MLEResults.zvalues"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.zvalues">[docs]</a>    <span class="k">def</span> <span class="nf">zvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The z-statistics for the coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span>
</div>
<div class="viewcode-block" id="MLEResults.test_normality"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.test_normality">[docs]</a>    <span class="k">def</span> <span class="nf">test_normality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for normality of standardized residuals.</span>

<span class="sd">        Null hypothesis is normality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;jarquebera&#39;} or None</span>
<span class="sd">            The statistical test for normality. Must be &#39;jarquebera&#39; for</span>
<span class="sd">            Jarque-Bera normality test. If None, an attempt is made to select</span>
<span class="sd">            an appropriate test.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the first `d` loglikelihood values were burned (i.e. in the</span>
<span class="sd">        specified model, `loglikelihood_burn=d`), then this test is calculated</span>
<span class="sd">        ignoring the first `d` residuals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.stattools.jarque_bera</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;jarquebera&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;jarquebera&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="kn">import</span> <span class="n">jarque_bera</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jarque_bera</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">d</span><span class="p">:],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Invalid normality test method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>
</div>
<div class="viewcode-block" id="MLEResults.test_heteroskedasticity"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.test_heteroskedasticity">[docs]</a>    <span class="k">def</span> <span class="nf">test_heteroskedasticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;two-sided&#39;</span><span class="p">,</span>
                                <span class="n">use_f</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Test for heteroskedasticity of standardized residuals</span>

<span class="sd">        Tests whether the sum-of-squares in the first third of the sample is</span>
<span class="sd">        significantly different than the sum-of-squares in the last third</span>
<span class="sd">        of the sample. Analogous to a Goldfeld-Quandt test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;breakvar&#39;} or None</span>
<span class="sd">            The statistical test for heteroskedasticity. Must be &#39;breakvar&#39;</span>
<span class="sd">            for test of a break in the variance. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        alternative : string, &#39;increasing&#39;, &#39;decreasing&#39; or &#39;two-sided&#39;</span>
<span class="sd">            This specifies the alternative for the p-value calculation. Default</span>
<span class="sd">            is two-sided.</span>
<span class="sd">        use_f : boolean, optional</span>
<span class="sd">            Whether or not to compare against the asymptotic distribution</span>
<span class="sd">            (chi-squared) or the approximate small-sample distribution (F).</span>
<span class="sd">            Default is True (i.e. default is to compare against an F</span>
<span class="sd">            distribution).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The null hypothesis is of no heteroskedasticity. That means different</span>
<span class="sd">        things depending on which alternative is selected:</span>

<span class="sd">        - Increasing: Null hypothesis is that the variance is not increasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the later</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the earlier</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Decreasing: Null hypothesis is that the variance is not decreasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the later</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Two-sided: Null hypothesis is that the variance is not changing</span>
<span class="sd">          throughout the sample. Both that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is not greater than the sum-of-squares in the later</span>
<span class="sd">          subsample *and* that the sum-of-squares in the later subsample is</span>
<span class="sd">          not greater than the sum-of-squares in the earlier subsample.</span>

<span class="sd">        For :math:`h = [T/3]`, the test statistic is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H(h) = \sum_{t=T-h+1}^T  \tilde v_t^2</span>
<span class="sd">            \left / \sum_{t=d+1}^{d+1+h} \tilde v_t^2 \right .</span>

<span class="sd">        where :math:`d` is the number of periods in which the loglikelihood was</span>
<span class="sd">        burned in the parent model (usually corresponding to diffuse</span>
<span class="sd">        initialization).</span>

<span class="sd">        This statistic can be tested against an :math:`F(h,h)` distribution.</span>
<span class="sd">        Alternatively, :math:`h H(h)` is asymptotically distributed according</span>
<span class="sd">        to :math:`\chi_h^2`; this second test can be applied by passing</span>
<span class="sd">        `asymptotic=True` as an argument.</span>

<span class="sd">        See section 5.4 of [1]_ for the above formula and discussion, as well</span>
<span class="sd">        as additional details.</span>

<span class="sd">        TODO</span>

<span class="sd">        - Allow specification of :math:`h`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : array</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable. The array is then sized `(k_endog, 2)`. If the method is</span>
<span class="sd">            called as `het = res.test_heteroskedasticity()`, then `het[0]` is</span>
<span class="sd">            an array of size 2 corresponding to the first endogenous variable,</span>
<span class="sd">            where `het[0][0]` is the test statistic, and `het[0][1]` is the</span>
<span class="sd">            p-value.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Harvey, Andrew C. 1990.</span>
<span class="sd">           Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">           Cambridge University Press.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;breakvar&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;breakvar&#39;</span><span class="p">:</span>
            <span class="c"># Store some values</span>
            <span class="n">squared_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>

            <span class="c"># Calculate the test statistics for each endogenous variable</span>
            <span class="n">test_statistics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="n">h</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">:</span><span class="n">d</span><span class="o">+</span><span class="n">h</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)</span>
            <span class="p">])</span>

            <span class="c"># Setup functions to calculate the p-values</span>
            <span class="k">if</span> <span class="n">use_f</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">f</span>
                <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
                <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">chi2</span>
                <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
                <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

            <span class="c"># Calculate the one- or two-sided p-values</span>
            <span class="n">alternative</span> <span class="o">=</span> <span class="n">alternative</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;inc&#39;</span><span class="p">,</span> <span class="s">&#39;increasing&#39;</span><span class="p">]:</span>
                <span class="n">p_values</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;dec&#39;</span><span class="p">,</span> <span class="s">&#39;decreasing&#39;</span><span class="p">]:</span>
                <span class="n">test_statistics</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">test_statistics</span>
                <span class="n">p_values</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2-sided&#39;</span><span class="p">,</span> <span class="s">&#39;two-sided&#39;</span><span class="p">]:</span>
                <span class="n">p_values</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                    <span class="n">pval_lower</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">),</span>
                    <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistics</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid alternative.&#39;</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">p_values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Invalid heteroskedasticity test&#39;</span>
                                      <span class="s">&#39; method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>
</div>
<div class="viewcode-block" id="MLEResults.test_serial_correlation"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.test_serial_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">test_serial_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ljung-box test for no serial correlation of standardized residuals</span>

<span class="sd">        Null hypothesis is no serial correlation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;ljungbox&#39;,&#39;boxpierece&#39;} or None</span>
<span class="sd">            The statistical test for serial correlation. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        lags : None, int or array_like</span>
<span class="sd">            If lags is an integer then this is taken to be the largest lag</span>
<span class="sd">            that is included, the test result is reported for all smaller lag</span>
<span class="sd">            length.</span>
<span class="sd">            If lags is a list or array, then all lags are included up to the</span>
<span class="sd">            largest lag in the list, however only the tests for the lags in the</span>
<span class="sd">            list are reported.</span>
<span class="sd">            If lags is None, then the default maxlag is 12*(nobs/100)^{1/4}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : array</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable and each lag. The array is then sized</span>
<span class="sd">            `(k_endog, 2, lags)`. If the method is called as</span>
<span class="sd">            `ljungbox = res.test_serial_correlation()`, then `ljungbox[i]`</span>
<span class="sd">            holds the results of the Ljung-Box test (as would be returned by</span>
<span class="sd">            `statsmodels.stats.diagnostic.acorr_ljungbox`) for the `i`th</span>
<span class="sd">            endogenous variable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the first `d` loglikelihood values were burned (i.e. in the</span>
<span class="sd">        specified model, `loglikelihood_burn=d`), then this test is calculated</span>
<span class="sd">        ignoring the first `d` residuals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.diagnostic.acorr_ljungbox</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;ljungbox&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;ljungbox&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;boxpierce&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.diagnostic</span> <span class="kn">import</span> <span class="n">acorr_ljungbox</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c"># Default lags for acorr_ljungbox is 40, but may not always have</span>
            <span class="c"># that many observations</span>
            <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">acorr_ljungbox</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">:],</span>
                    <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">boxpierce</span><span class="o">=</span><span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;boxpierce&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;ljungbox&#39;</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Invalid serial correlation test&#39;</span>
                                      <span class="s">&#39; method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</div>
<div class="viewcode-block" id="MLEResults.get_prediction"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.get_prediction">[docs]</a>    <span class="k">def</span> <span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : boolean, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Handle start and end (e.g. dates)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_predict_start</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_predict_end</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="c"># Handle string dynamic</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dates</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Got a string for dynamic and dates is None&quot;</span><span class="p">)</span>
            <span class="n">dtdynamic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_str_to_date</span><span class="p">(</span><span class="n">dynamic</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dynamic_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_dates_loc</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">dtdynamic</span><span class="p">)</span>

                <span class="n">dynamic</span> <span class="o">=</span> <span class="n">dynamic_start</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dynamic must be in dates. Got </span><span class="si">%s</span><span class="s"> | </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dynamic</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtdynamic</span><span class="p">)))</span>

        <span class="c"># Perform the prediction</span>
        <span class="c"># This is a (k_endog x npredictions) array; don&#39;t want to squeeze in</span>
        <span class="c"># case of npredictions = 1</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">+</span><span class="n">out_of_sample</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c"># Return a new mlemodel.PredictionResults object</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">row_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">row_labels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">predict_dates</span>
        <span class="k">return</span> <span class="n">PredictionResultsWrapper</span><span class="p">(</span>
            <span class="n">PredictionResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">row_labels</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="MLEResults.get_forecast"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.get_forecast">[docs]</a>    <span class="k">def</span> <span class="nf">get_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="o">+</span><span class="n">steps</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEResults.predict"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : boolean, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Handle start and end (e.g. dates)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_predict_start</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_predict_end</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="c"># Handle string dynamic</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dates</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Got a string for dynamic and dates is None&quot;</span><span class="p">)</span>
            <span class="n">dtdynamic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_str_to_date</span><span class="p">(</span><span class="n">dynamic</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dynamic_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_dates_loc</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">dtdynamic</span><span class="p">)</span>

                <span class="n">dynamic</span> <span class="o">=</span> <span class="n">dynamic_start</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dynamic must be in dates. Got </span><span class="si">%s</span><span class="s"> | </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dynamic</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtdynamic</span><span class="p">)))</span>

        <span class="c"># Perform the prediction</span>
        <span class="c"># This is a (k_endog x npredictions) array; don&#39;t want to squeeze in</span>
        <span class="c"># case of npredictions = 1</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">+</span><span class="n">out_of_sample</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">predicted_mean</span>
</div>
<div class="viewcode-block" id="MLEResults.forecast"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.forecast">[docs]</a>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="o">+</span><span class="n">steps</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEResults.simulate"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span>
            <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEResults.impulse_responses"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span>
            <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MLEResults.plot_diagnostics"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.plot_diagnostics">[docs]</a>    <span class="k">def</span> <span class="nf">plot_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagnostic plots for standardized residuals of one endogenous variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : integer, optional</span>
<span class="sd">            Index of the endogenous variable for which the diagnostic plots</span>
<span class="sd">            should be created. Default is 0.</span>
<span class="sd">        lags : integer, optional</span>
<span class="sd">            Number of lags to include in the correlogram. Default is 10.</span>
<span class="sd">        fig : Matplotlib Figure instance, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the 2x2 grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Produces a 2x2 plot grid with the following plots (ordered clockwise</span>
<span class="sd">        from top left):</span>

<span class="sd">        1. Standardized residuals over time</span>
<span class="sd">        2. Histogram plus estimated density of standardized residulas, along</span>
<span class="sd">           with a Normal(0,1) density plotted for reference.</span>
<span class="sd">        3. Normal Q-Q plot, with Normal reference line.</span>
<span class="sd">        4. Correlogram</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.graphics.gofplots.qqplot</span>
<span class="sd">        statsmodels.graphics.tsaplots.plot_acf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.utils</span> <span class="kn">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>
        <span class="c"># Eliminate residuals associated with burned likelihoods</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>

        <span class="c"># Top-left: residuals vs time</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">221</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;dates&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:]</span><span class="o">.</span><span class="n">_mpl_repr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Standardized residual&#39;</span><span class="p">)</span>

        <span class="c"># Top-right: histogram, Gaussian kernel density, Normal density</span>
        <span class="c"># Can only do histogram and Gaussian kernel density on the non-null</span>
        <span class="c"># elements</span>
        <span class="n">resid_nonmissing</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">))]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">222</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Hist&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span><span class="p">,</span> <span class="n">norm</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kde</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;KDE&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;N(0,1)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Histogram plus estimated density&#39;</span><span class="p">)</span>

        <span class="c"># Bottom-left: QQ plot</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">223</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.gofplots</span> <span class="kn">import</span> <span class="n">qqplot</span>
        <span class="n">qqplot</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Normal Q-Q&#39;</span><span class="p">)</span>

        <span class="c"># Bottom-right: Correlogram</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">224</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.tsaplots</span> <span class="kn">import</span> <span class="n">plot_acf</span>
        <span class="n">plot_acf</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Correlogram&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span>
</div>
<div class="viewcode-block" id="MLEResults.summary"><a class="viewcode-back" href="../../../../reference/ssm/mlemodel.html#dismalpy.ssm.mlemodel.MLEResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        model_name : string</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>

        <span class="c"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Statespace Model Results&#39;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%02d</span><span class="s">-</span><span class="si">%02d</span><span class="s">-</span><span class="si">%02d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&#39;- &#39;</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%02d</span><span class="s">-</span><span class="si">%02d</span><span class="s">-</span><span class="si">%02d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s">&#39; - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

        <span class="c"># Diagnostic tests results</span>
        <span class="n">het</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_heteroskedasticity</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;breakvar&#39;</span><span class="p">)</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_serial_correlation</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;ljungbox&#39;</span><span class="p">)</span>
        <span class="n">jb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_normality</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;jarquebera&#39;</span><span class="p">)</span>

        <span class="c"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;+ &#39;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;Date:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Time:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Sample:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s">&#39;Log Likelihood&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%#5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
            <span class="p">(</span><span class="s">&#39;AIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%#5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s">&#39;BIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%#5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s">&#39;HQIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%#5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;cov_type&#39;</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;Covariance Type:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="n">format_str</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;{0:.2f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">diagn_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Ljung-Box (Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s">&#39;Prob(Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s">&#39;Heteroskedasticity (H):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s">&#39;Prob(H) (two-sided):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
                      <span class="p">]</span>

        <span class="n">diagn_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Jarque-Bera (JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s">&#39;Prob(JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s">&#39;Skew:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s">&#39;Kurtosis:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]))</span>
                       <span class="p">]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">display_params</span><span class="p">:</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">xname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">diagn_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">diagn_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span>

        <span class="c"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;cov_type&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&#39;description&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s">&#39;description&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Covariance matrix is singular or near-singular,&quot;</span>
                         <span class="s">&quot; with condition number </span><span class="si">%6.3g</span><span class="s">. Standard errors may be&quot;</span>
                         <span class="s">&quot; unstable.&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;[{0}] {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Warnings:&quot;</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span>

</div>
<span class="k">class</span> <span class="nc">MLEResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;zvalues&#39;</span><span class="p">:</span> <span class="s">&#39;columns&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_cs&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_default&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_delta&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_oim&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_opg&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_robust&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_robust_cs&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;cov_params_robust_oim&#39;</span><span class="p">:</span> <span class="s">&#39;cov&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;forecast&#39;</span><span class="p">:</span> <span class="s">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s">&#39;simulate&#39;</span><span class="p">:</span> <span class="s">&#39;ynames&#39;</span><span class="p">,</span>
        <span class="s">&#39;impulse_responses&#39;</span><span class="p">:</span> <span class="s">&#39;ynames&#39;</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MLEResultsWrapper</span><span class="p">,</span> <span class="n">MLEResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">PredictionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prediction_results : kalman_filter.PredictionResults instance</span>
<span class="sd">        Results object from prediction after fitting or filtering a state space</span>
<span class="sd">        model.</span>
<span class="sd">    row_labels : iterable</span>
<span class="sd">        Row labels for the predicted data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">predict_dates</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;predict_dates&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span> <span class="o">=</span> <span class="n">prediction_results</span>

        <span class="c"># Get required values</span>
        <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts_error_cov</span>
        <span class="k">if</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c"># Initialize</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="n">var_pred_mean</span><span class="p">,</span>
                                                <span class="n">dist</span><span class="o">=</span><span class="s">&#39;norm&#39;</span><span class="p">,</span>
                                                <span class="n">row_labels</span><span class="o">=</span><span class="n">row_labels</span><span class="p">,</span>
                                                <span class="n">link</span><span class="o">=</span><span class="n">identity</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;endpoint&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c"># TODO: this performs metadata wrapping, and that should be handled</span>
        <span class="c">#       by attach_* methods. However, they don&#39;t currently support</span>
        <span class="c">#       this use case.</span>
        <span class="n">conf_int</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">predict_dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">conf_int</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">conf_int</span><span class="p">,</span>
                                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">predict_dates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">conf_int</span>

    <span class="k">def</span> <span class="nf">summary_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="c"># TODO: finish and cleanup</span>
        <span class="c"># import pandas as pd</span>
        <span class="kn">from</span> <span class="nn">statsmodels.compat.collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
        <span class="c">#ci_obs = self.conf_int(alpha=alpha, obs=True) # need to split</span>
        <span class="n">ci_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">to_include</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span><span class="p">[</span><span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean_ci_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s">&#39;mean_ci_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">k_endog</span> <span class="o">+</span> <span class="n">endog</span><span class="p">]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">to_include</span>
        <span class="c">#OrderedDict doesn&#39;t work to preserve sequence</span>
        <span class="c"># pandas dict doesn&#39;t handle 2d_array</span>
        <span class="c">#data = np.column_stack(list(to_include.values()))</span>
        <span class="c">#names = ....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">to_include</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">,</span>
                           <span class="n">columns</span><span class="o">=</span><span class="n">to_include</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">res</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">yname</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">class</span> <span class="nc">PredictionResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;predicted_mean&#39;</span><span class="p">:</span> <span class="s">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s">&#39;se_mean&#39;</span><span class="p">:</span> <span class="s">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s">&#39;t_values&#39;</span><span class="p">:</span> <span class="s">&#39;dates&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_attrs</span><span class="p">)</span>

    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PredictionResultsWrapper</span><span class="p">,</span> <span class="n">PredictionResults</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Chad Fulton.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>